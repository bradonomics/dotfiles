#!/bin/bash

# Usage: extract <file>
# Description: extracts archived files
extract() {
  if [[ -f $1 ]]; then
    case $1 in
      *.tar.bz2) tar -jxf $1  ;;
      *.bz2)     bzip2 -dk $1 ;;
			*.tar.gz)  tar -xzf $1  ;;
      *.gz)      gzip -dk $1  ;;
			*.tar.xz)  tar -Jxf $1  ;;
      *.xz)      tar -Jxf $1  ;;
			*.tar)     tar -xf $1   ;;
			*.taz)     tar -xzf $1  ;;
			*.tb2)     tar -jxf $1  ;;
			*.tbz)     tar -jxf $1  ;;
			*.tbz2)    tar -jxf $1  ;;
			*.tgz)     tar -xzf $1  ;;
			*.txz)     tar -Jxf $1  ;;
			*.zip)     unzip $1     ;;
      *)         echo "'$1' cannot be extracted/mounted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Usage: startapache
# Description: starts apache webserver
startapache() {
  START="sudo service apache2 start"
  PGREP="/usr/bin/pgrep" # path to pgrep command
  HTTPD="apache2" # Httpd daemon name
  $PGREP ${HTTPD} # find httpd pid
  if [ $? -ne 0 ]; then # if apache is not running
    $START
  fi
}

# Usage: stopapache
# Description: stops apache webserver (different than start command above for reference)
stopapache() {
  SERVICE="apache2"
  STOP="sudo service apache2 stop"
  if (( $(ps -ef | grep -v grep | grep $SERVICE | wc -l) > 0 )); then # if apache not running
    $STOP
  fi
}

# Usage: gulpinstall
# Description: Prompts for project type, initializes node package manager, and installs gulp
gulpinstall() {
  # Create package.json file
  npm init

  # WordPress or Jekyll
  read -r -p "Is this a WordPress or Jekyll project? [w/j] " RESPONSE
  RESPONSE=${RESPONSE,,}

  if [[ $RESPONSE == w ]]; then
    npm install --save-dev gulp gulp-sass gulp-autoprefixer gulp-cssnano gulp-concat gulp-uglify gulp-rename browser-sync
  elif [[ $RESPONSE == j ]]; then
    npm install --save-dev gulp gulp-shell gulp-concat gulp-uglify gulp-rename browser-sync
  else
    echo "You must select 'w' for WordPress or 'j' for Jekyll."
    echo "Try again."
  fi
}

# Usage: calibre
# Description: upgrade calibre to lastest verion
calibre() {
  wget -nv -O- https://download.calibre-ebook.com/linux-installer.py | sudo python -c "import sys; main=lambda:sys.stderr.write('Download failed\n'); exec(sys.stdin.read()); main()"
}

# Usage: a <directory>
# Description: `a` with no arguments opens the current directory in Atom Editor, otherwise opens the given location
function a() {
	if [ $# -eq 0 ]; then
		atom .;
	else
		atom "$@";
	fi;
}

# Usage: symlinkallthethings
# Description: Runs all symlink functions (usful when installing a new system)
symlinkallthethings() {
  symlinkdotfiles
  symlinkbin
  symlinkfonts
  symlinkredshift
}

# Usage: symlinkdotfiles
# Description: Creates a symbolic link of files in ~/.dotfiles to ~/ (and refreshes existing links with -f).
symlinkdotfiles() {
  # Grab our current directory so we can get back there after the magic happes.
  DIR=${PWD}

  # Move to the ~/.dotfiles directory
  cd ~/.dotfiles || exit

  # Grab all the files and loop through them adding a symlink
  FILES="*"
  for FILE in $FILES; do
    if [ ! -d "$FILE" ]; then
      ln -sfv ~/.dotfiles/$FILE ~/.$FILE;
    fi
  done

  # Go back to the directory where we started
  cd $DIR || exit
}

# Usage: symlinkbin
# Description: Creates a symbolic link of files in ~/.dotfiles/bin to ~/bin (and refreshes existing links with -f).
symlinkbin() {
  # Grab our current directory so we can get back there after the magic happes.
  DIR=${PWD}

  # If there isn't already a bin directory, create one
  if [ ! -d ~/bin ]; then
    mkdir -p ~/bin;
  fi

  # Move to the /bin directory in our dotfiles repo
  cd ~/.dotfiles/bin || exit

  # Grab all the files and loop through them adding a symlink
  FILES="*"
  for FILE in $FILES; do
    ln -sfv ~/.dotfiles/bin/$FILE ~/bin/$FILE;
  done

  # Move the the ~/bin directory and make all files executable
  cd ~/bin || exit
  FILES="*"
  for FILE in $FILES; do
    chmod +x $FILE;
  done

  # Go back to the directory where we started
  cd $DIR || exit
}

# Usage: symlinkfonts
# Description: Creates a symbolic link of files in ~/.dotfiles/fonts to ~/.fonts (and refreshes existing links with -f).
symlinkfonts() {
  # Grab our current directory so we can get back there after the magic happes.
  DIR=${PWD}

  # Move to the /bin directory in our dotfiles repo
  cd ~/.dotfiles/fonts || exit

  # Grab all the files and loop through them adding a symlink
  FILES="*"
  for FILE in $FILES; do
    ln -sf ~/.dotfiles/fonts/$FILE ~/.fonts/$FILE;
  done

  # Rebuild font cache
  fc-cache -fv

  # Go back to the directory where we started
  cd $DIR || exit
}

# Usage: symlinkredshift
# Description: Creates a symbolic link of ~/.dotfiles/config to ~/.config (and refreshes existing links with -f).
symlinkredshift() {
  # Grab our current directory so we can get back there after the magic happes.
  DIR=${PWD}

  # Move to the /bin directory in our dotfiles repo
  cd ~/.dotfiles/config || exit

  # Grab all the files and loop through them adding a symlink
  FILES="*"
  for FILE in $FILES; do
    ln -sf ~/.dotfiles/config/$FILE ~/.config/$FILE;
  done

  # Go back to the directory where we started
  cd $DIR || exit
}
