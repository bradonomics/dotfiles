#!/bin/bash

# Starts apache webserver
start-apache() {
  START="sudo service apache2 start"
  PGREP="/usr/bin/pgrep" # path to pgrep command
  HTTPD="apache2" # Httpd daemon name
  $PGREP ${HTTPD} # find httpd pid
  if [ $? -ne 0 ]; then # if apache is not running
    $START
  fi
}

# Stops apache webserver (different than start command above for reference)
stop-apache() {
  SERVICE="apache2"
  STOP="sudo service apache2 stop"
  if (( $(ps -ef | grep -v grep | grep $SERVICE | wc -l) > 0 )); then # if apache not running
    $STOP
  fi
}

# Adds apache to start at boot
enable-apache() {
  sudo update-rc.d apache2 defaults
}

# Prevents apache from starting at boot
disable-apache() {
  sudo update-rc.d apache2 disable
}

# Starts mysql service
start-mysql() {
  sudo systemctl start mysql
}

# Stops mysql service
stop-mysql() {
  sudo systemctl stop mysql
}

# Adds mysql to start at boot
enable-mysql() {
  sudo systemctl enable mysql
}

# Prevents mysql from starting at boot
disable-mysql() {
  sudo systemctl disable mysql
}

# Upgrade gitkraken to the latest version
gitkraken() {
  sudo wget https://release.gitkraken.com/linux/gitkraken-amd64.deb
  sudo gdebi --non-interactive gitkraken-amd64.deb
  rm -f gitkraken-amd64.deb
}

# Upgrade calibre to lastest verion
calibre() {
  wget -nv -O- https://download.calibre-ebook.com/linux-installer.py | sudo python -c "import sys; main=lambda:sys.stderr.write('Download failed\n'); exec(sys.stdin.read()); main()"
}

# `a` with no arguments opens the current directory in Atom Editor, otherwise opens the given location
function a() {
	if [ $# -eq 0 ]; then
		atom .;
	else
		atom "$@";
	fi;
}

# `c` with no arguments opens the current directory in Visual Studio Code, otherwise opens the given location
function c() {
	if [ $# -eq 0 ]; then
		code .;
	else
		code "$@";
	fi;
}

# Runs all symlink functions (usful when installing a new system)
symlinkallthethings() {
  symlinkdotfiles
  symlinkbin
  symlinkfonts
  symlinkredshift
}

# Creates a symbolic link of files in ~/.dotfiles to ~/ (and refreshes existing links with -f).
symlinkdotfiles() {
  # Grab our current directory so we can get back there after the magic happes.
  DIR=${PWD}

  # Move to the ~/.dotfiles directory
  cd ~/.dotfiles || exit

  # Grab all the files and loop through them adding a symlink
  FILES="*"
  for FILE in $FILES; do
    if [ ! -d "$FILE" ]; then
      ln -sfv ~/.dotfiles/$FILE ~/.$FILE;
    fi
  done

  # Go back to the directory where we started
  cd $DIR || exit
}

# Creates a symbolic link of files in ~/.dotfiles/bin to ~/bin (and refreshes existing links with -f).
symlinkbin() {
  # Grab our current directory so we can get back there after the magic happes.
  DIR=${PWD}

  # If there isn't already a bin directory, create one
  if [ ! -d ~/bin ]; then
    mkdir -p ~/bin;
  fi

  # Move to the /bin directory in our dotfiles repo
  cd ~/.dotfiles/bin || exit

  # Grab all the files and loop through them adding a symlink
  FILES="*"
  for FILE in $FILES; do
    ln -sfv ~/.dotfiles/bin/$FILE ~/bin/$FILE;
  done

  # Move the the ~/bin directory and make all files executable
  cd ~/bin || exit
  FILES="*"
  for FILE in $FILES; do
    chmod +x $FILE;
  done

  # Go back to the directory where we started
  cd $DIR || exit
}

# Creates a symbolic link of files in ~/.dotfiles/fonts to ~/.fonts (and refreshes existing links with -f).
symlinkfonts() {
  # Grab our current directory so we can get back there after the magic happes.
  DIR=${PWD}

  # Move to the /bin directory in our dotfiles repo
  cd ~/.dotfiles/fonts || exit

  # Grab all the files and loop through them adding a symlink
  FILES="*"
  for FILE in $FILES; do
    ln -sf ~/.dotfiles/fonts/$FILE ~/.fonts/$FILE;
  done

  # Rebuild font cache
  fc-cache -fv

  # Go back to the directory where we started
  cd $DIR || exit
}

# Creates a symbolic link of ~/.dotfiles/config to ~/.config (and refreshes existing links with -f).
symlinkredshift() {
  # Grab our current directory so we can get back there after the magic happes.
  DIR=${PWD}

  # Move to the /.dotfiles/config directory in our dotfiles repo
  cd ~/.dotfiles/config || exit

  # Grab all the files and loop through them adding a symlink
  FILES="*"
  for FILE in $FILES; do
    ln -sf ~/.dotfiles/config/$FILE ~/.config/$FILE;
  done

  # Go back to the directory where we started
  cd $DIR || exit
}

# Renames all files in current directory.
renamefiles() {
  read -r -p "What file extension are we looping? (no dot) " FILE_EXT
  read -r -p "What is the existing character or pattern you want to replace? " OLD
  read -r -p "What is the new character or pattern you want? " NEW
  FILES="*.$FILE_EXT"

  for file in $FILES; do
    mv "$file" "${file/${OLD}/${NEW}}"
  done
}

# List NPM packages without dependencies
npm() {
  if [ $1 == "list" ]; then
    command npm list --depth=0 "${@:2}";
    echo "For a list with dependencies, use 'ls'.";
  else
    command npm "$@";
  fi
}
